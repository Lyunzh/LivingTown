# PelicanNet：数据持久化与社交演化报告

此文档补充了此前在 AI 宏观叙事下被忽视的“脏活累活”——**底层连续性状态的数据持久化机制。**

如果只是简单地告诉 LLM “皮埃尔因为玩家大量卖蓝莓而降价”，那么这个行为在没有任何数据记录的情况下，根本无法被判定触发。AI 模型是无状态的（Stateless API），但小镇的经济和社交必须有状态。

---

## 1. 核心缺失中间件：GameStateTracker (游戏隐性状态叠加器)

必须在 `PelicanNet` 架构中引入一个单例服务 `GameStateTracker`，它紧贴 SMAPI 的事件钩子，作为一个只进不出的“记账房”。

### 1.1 玩家出货行为累计 (经济系统)
当玩家把 100 个蓝莓扔进出货箱，游戏的原生 API 结算后，这笔账在游戏内存中就结束了。我们要手动截获它。

- **逻辑抓取**：监听 `GameLoop.DayEnding`，抓取 `Game1.getFarm().getShippingBin(Game1.player)` 里的物品清单。
- **状态累计存盘**：
  将数据写入一个独立生成的本地 `mod_economy_tracker.json` 中：
  ```json
  {
    "Blueberry_ConsecutiveDays": 3,
    "Blueberry_TotalDumped": 350
  }
  ```
- **阈值触发器**：第二天 `DayStarted` 时，系统扫描此 JSON。如果发现某作物连续出货天数 `> 2` 且总数 `> 300`，立即拨动一个开关变量 `Global_Blueberry_Crash = true`，并强行将该状态写入当天生成 AI 动态的 Prompt 头部中。

### 1.2 社交疲劳与多日追踪 (舔狗防沉迷系统)
原版的好感度（Friendship Points）只管加深，不记录获取的历史密度。为了实现“觉得玩家烦人（CreepedOut）”的系统，需要为每个 NPC 单独建立**骚扰时间线**。

- 在 NPC 的 `modData` 中植入一个专有字典标签 `"PelicanNet_SocialFatigue"`。
- **频次衰减算法**：
  玩家当天对话 +1 疲劳点，送礼 +5 点。
  若当天未交互，夜间结算时疲劳点 `-3`（每日自然衰减）。
  当疲劳点飙升过 `15`，触发 `IsCreepedOut = true`，这时候无论玩家送什么超级喜爱（Loved）的物品，全部替换成“能别来烦我了吗”的 LLM 判定反馈。

---

## 2. “鹈鹕通”生态：从逻辑到展示的闭环

我们必须弄清楚数据的生命周期：**累计数据 -> 触发阈值开关 -> 引发 LLM 表达 -> 呈现在虚构智能手机上。**

### 2.1 TownFeed 信息流的异步生成与读取
TownFeed 绝对不能在玩家每次点开手机时临时向 LLM 请求网络数据。

- **离线预渲染机制**：所有的 TownFeed 动态（Posts）必须在玩家**前一天晚上睡觉黑屏时**，通过 C# 后台并行向 Python 服务端请求完毕，并将生成的文本直接保存在玩家手机的本地数据库文件里。
- **展示端**：玩家早上起床点开手机 App，看到的所有内容都只是读取本地 `posts.json` 的文本缓存。完全零延迟。

### 2.2 经济市场 (MarketWatch) 的降级方案
皮埃尔的降价抱怨不一定非要通过 LLM 大端侧。对于高度模式化的“蓝莓滞销”事件，直接在系统中备用多套固定模板语言（如：“又双叒收到这么多蓝莓！我要降价了！”）。仅在有特殊组合（如同时出货蓝莓和葡萄引起双连带暴跌）或在 TownFeed 评论区发生了连环骂战时，再出动 LLM 进行上下文逻辑润色，以节省 Token 开支。

---

## 3. 结论归核

任何“活着的 AI 小镇”不在天上，而在那些极其琐碎的 JSON 数据字段里。没有 `GameStateTracker` 这个底层去把玩家那些“自以为没人注意的连续小动作”一笔笔记下来，哪怕挂最顶级的 GPT-4，输出的照样也只是不知所云的套话流水账。持久化，是实现 AI 质变的根本底座。
